## Лекции
Здесь будут реализованы практические задания с лекций.

Коды в папках можно скомпилировать с make-файлом или использовать компилятор gcc в ручную, с помощью команды `gcc program_filename.c -o executable_filename.out`. Но лучше пользоваться Makefile'ом. Для использования make-файла необходимо находиться в корневой папке репозитория.

Оглавление:
+ [Lec2_Lec3](#Lecture2-3)
   + [Program 1](#Program_1)
   + [Program 2](#Program_2)
   + [Program 3](#Program_3)
+ [Lec4](#Lecture4)
   + [Program 1](#Program_12)
   + [Program 2](#Program_22)
   + [Program 3](#Program_32)

Структура Makefile:
- all
  - Lec2_Lec3_1
  - Lec2_Lec3_2
  - Lec2_Lec3_3
  - Lec4_1
  - Lec4_2
  - Lec4_3
## Обзор программ и результов их работы
___
## <a name="Lecture2-3">Лекции 2-3</a>
#### <a name="Program_1">Program 1</a>
Пример динамического выделения памяти для массива.
Выделяется память с помощью malloc. При выделении памяти возвращается указатель, который будет равен NULL, если память не выделилась. Если массив инициализирован, то выделенная память осовобождается.
Тестирование:
```
Enter length of array: 1
All fine
```
Тестирование:
```
Enter length of array: -10
Error: can't allocate memory
```
___ 
#### <a name="Program_2">Program 2</a>
Пример для чтения данных из файла.
Выделяем память для массива чаров с помощью calloc. Создаем дескриптор и открываем файл для чтения, файл будет создан даже если его нет. Выводим значение дескриптора файла. После читаем из файла 10 байт и записываем в переменную `sz` количество байт, которое удалось прочитать. Записываем в конец массива символ конца строки. В конце программы закрываем файл.
Тестирование 
```
fd = 3
called read(3, c, 10). returned that 0 bytes were read.
closed the fd.
```
___
#### <a name="Program_3">Program 3</a>
Системный вызов fork().
Вызывается системный вызов fork(). После программа делится на двое и в результате вызова функции появляется один ребенок. С помощью switch-case мы определяем, каким является процесс - ошибка `(case -1:)` или ребенок `(case 0:)`, или родитель `(default:)`. Как правило, процесс ребенка всегда больше, чем у родителя, а определяется это с помощью функции `getpid()`.
Тестирование:
```
my pid = 22781, returned pid = 22782
my pid = 22782, returned pid = 0
```
___
## <a name="Lecture4">Лекция 4</a>
#### <a name="Program_12">Program 1</a>
Сигналы.
В начале работы программы срабатывает системный вызов `signal()` и привязывает сигнал SIGUSR1 к одному из обработчиков `handler1`. Далее выполнятеся проверка на то, что мы ребенок и, если мы им оказываеся, то переопределяем обработчик `handler1` на `handler2`. Из ребенка используется системный вызов `kill()` и отправляется сигнал родителю. `handler1` и `handler2` - две обрабатывающие функции, которые принимают на вход наш сигнал с целочисленным типом данных.
Тестирование:
```
counter = 1  
counter = 3  
counter = 5  
```
___ 
#### <a name="Program_22">Program 2</a>
Неименованные каналы.
Для работы с неименованными каналами используются два дескриптора. Системный вызов `pipe` записывает два дескриптора с обработкой ошибок. Далее используется системный вызов `fork()` для получения дочернего процесса, и обрабатываем ошибки. Если `cpid` равняется 0, то процесс - потомок. Получается что один дескриптор - для чтения, а второй дескриптор - для записи. То есть сообщение передается между процессами с помощью каналов.
Тестирование 
```
./prog2.out unnamed
unnamed
```
___
#### <a name="Program_32">Program 3</a>
Именованные каналы.
Создаём дескриптор канала и именованный канал с правами доступа для всех. После запускается цикл прослушивания канала. В момент, когда в этот канал попадает сообщение, то выводится количество символов, включая 0 конца строки, и само сообщение.
Тестирование:
```
mypipe is created
$ echo Eureka! > mypipe
mypipe is opened
Incomming message (8): Eureka!

read error: Success
```
___
